"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  BaseDecryptor: () => BaseDecryptor,
  DeezerExtractor: () => DeezerExtractor,
  JSDecryptor: () => JSDecryptor,
  NodeDecryptor: () => NodeDecryptor,
  Warnings: () => Warnings,
  buildTrackFromSearch: () => buildTrackFromSearch,
  deezerRegex: () => deezerRegex,
  extractTrackId: () => extractTrackId,
  getCrypto: () => getCrypto,
  isUrl: () => isUrl,
  search: () => search,
  searchOneTrack: () => searchOneTrack,
  streamTrack: () => streamTrack,
  validate: () => validate
});
module.exports = __toCommonJS(src_exports);

// src/DeezerExtractor.ts
var import_deezer_music_metadata = require("@mithron/deezer-music-metadata");
var import_discord_player2 = require("discord-player");
var import_promises = require("timers/promises");

// src/utils/util.ts
var import_discord_player = require("discord-player");
var import_stream = require("stream");

// src/Crypto/JSDecryptor.ts
var import_blowfish_node = __toESM(require("blowfish-node"));

// src/Crypto/BaseDecryptor.ts
var BaseDecryptor = class {
  constructor(decryptionKey, iv) {
    this.key = decryptionKey;
    this.iv = iv;
  }
  async decrypt(chunk) {
    throw new Error("Not implemented");
  }
};

// src/Crypto/JSDecryptor.ts
var JSDecryptor = class extends BaseDecryptor {
  constructor(...args) {
    super(...args);
    this.bfDecryptor = new import_blowfish_node.default(new Uint8Array(this.key), import_blowfish_node.MODE.CBC, import_blowfish_node.PADDING.NULL);
    this.bfDecryptor.setIv(new Uint8Array(this.iv));
  }
  async decrypt(chunk) {
    const chunkUint = new Uint8Array(chunk);
    const decoded = this.bfDecryptor.decode(chunkUint, import_blowfish_node.TYPE.UINT8_ARRAY);
    return Buffer.from(decoded);
  }
};

// src/utils/util.ts
var IV = Buffer.from(Array.from({ length: 8 }, (_, x) => x));
var rawCrypto;
async function getCrypto() {
  if (!rawCrypto) {
    rawCrypto = await import("crypto");
    return rawCrypto;
  }
  return rawCrypto;
}
function isUrl(query) {
  try {
    const url = new URL(query);
    return ["https:", "http:"].includes(url.protocol);
  } catch {
    return false;
  }
}
var DeezerAPIRoutes = {
  searchTrack(query, limit) {
    const url = `https://api.deezer.com/search/track?q=${encodeURIComponent(query)}&${limit ? `limit=${limit}` : ""}`;
    return url;
  }
};
async function search(query, limit = 10) {
  const route = DeezerAPIRoutes.searchTrack(query, limit);
  const response = await fetch(route);
  if (!response.status.toString().startsWith("2"))
    throw new Error("Server responded with a non 2xx status.");
  const jsonTrack = await response.json();
  if (!jsonTrack.data || !Array.isArray(jsonTrack.data) || jsonTrack.data.length === 0)
    throw new Error(
      "Unable get tracks from Deezer for the query '" + query + "'"
    );
  return jsonTrack;
}
function buildTrackFromSearch(track, player, requestedBy) {
  const tracks = track.data.map(
    (v) => new import_discord_player.Track(player, {
      source: "arbitrary",
      duration: import_discord_player.Util.buildTimeCode(import_discord_player.Util.parseMS(v.duration * 1e3)),
      author: Array.isArray(v.artist) ? v.artist.map((a) => a.name).join(", ") : v.artist.name,
      url: v.link,
      title: v.title,
      thumbnail: v.album.cover_xl || v.album.cover_medium || v.album.cover || v.album.cover_small || "https://play-lh.googleusercontent.com/xtIOV8iPeAY4GrldTDo3CbLAEpbea2DqnfxaB4Nn2p5qz6KAiumY74qH86pgu1HA1A",
      live: false,
      requestedBy
    })
  );
  return tracks;
}
function extractTrackId(query) {
  if (!validate(query)) throw new Error("Invalid track url");
  const trackIdWithUrlParams = query.split("/").at(-1);
  if (!trackIdWithUrlParams) throw new Error("Cannot find track ID");
  return trackIdWithUrlParams.split("?")[0];
}
async function searchOneTrack(query) {
  const url = DeezerAPIRoutes.searchTrack(query, 1);
  const trackRes = await fetch(url);
  if (trackRes.status !== 200) throw new Error("Fetch failed");
  const trackData = await trackRes.json();
  return trackData;
}
async function streamTrack(track, ext) {
  const decryptionKey = ext.options.decryptionKey;
  if (!decryptionKey) throw new Error("MISSING DEEZER DECRYPTION KEY");
  const crypto = await getCrypto();
  const trackId = extractTrackId(track.url);
  const trackHash = crypto.createHash("md5").update(trackId, "ascii").digest("hex");
  const trackKey = Buffer.alloc(16);
  const Decryptor = ext.options.decryptor || JSDecryptor;
  for (let iter = 0; iter < 16; iter++)
    trackKey.writeInt8(
      trackHash[iter].charCodeAt(0) ^ trackHash[iter + 16].charCodeAt(0) ^ decryptionKey[iter].charCodeAt(0),
      iter
    );
  const trackInfoRes = await ext.fetch(
    `https://www.deezer.com/ajax/gw-light.php?method=song.getListData&input=3&api_version=1.0&api_token=${ext.userInfo.csrfToken}`,
    {
      method: "POST",
      headers: {
        Cookie: `${ext.userInfo.cookie}; arl=${ext.options.arl}`,
        "User-Agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:120.0) Gecko/20100101 Firefox/120.0",
        DNT: "1"
      },
      body: JSON.stringify({
        sng_ids: [trackId]
      })
    }
  );
  const songInfo = (await trackInfoRes.json()).results.data[0];
  const streamInfoRes = await fetch("https://media.deezer.com/v1/get_url", {
    method: "POST",
    body: JSON.stringify({
      license_token: ext.userInfo.licenseToken,
      media: [
        {
          type: "FULL",
          formats: [
            {
              cipher: "BF_CBC_STRIPE",
              format: "FLAC"
            },
            {
              cipher: "BF_CBC_STRIPE",
              format: "MP3_256"
            },
            {
              cipher: "BF_CBC_STRIPE",
              format: "MP3_128"
            },
            {
              cipher: "BF_CBC_STRIPE",
              format: "MP3_MISC"
            }
          ]
        }
      ],
      track_tokens: [songInfo.TRACK_TOKEN]
    })
  });
  const streamInfo = await streamInfoRes.json();
  const trackMediaUrl = streamInfo.data[0].media[0].sources[0].url;
  ext.context.player.debug("DEEZER FOUND MEDIA URL " + trackMediaUrl);
  const trackReq = await ext.fetch(trackMediaUrl);
  const readable = import_stream.Readable.fromWeb(trackReq.body);
  let buffer = Buffer.alloc(0);
  let i = 0;
  const bufferSize = 2048;
  const passThrough = new import_stream.PassThrough();
  const decryptor = new Decryptor(trackKey, IV);
  readable.on("readable", async () => {
    let chunk = null;
    while (true) {
      chunk = readable.read(bufferSize);
      if (!chunk) {
        if (readable.readableLength) {
          chunk = readable.read(readable.readableLength);
          buffer = Buffer.concat([buffer, chunk]);
        }
        break;
      } else {
        buffer = Buffer.concat([buffer, chunk]);
      }
      while (buffer.length >= bufferSize) {
        const bufferSized = buffer.subarray(0, bufferSize);
        if (i % 3 === 0) {
          const decipher = await decryptor.decrypt(bufferSized);
          passThrough.write(decipher);
        } else {
          passThrough.write(bufferSized);
        }
        i++;
        buffer = buffer.subarray(bufferSize);
      }
    }
  });
  return passThrough;
}
var deezerRegex = {
  track: /(^https:)\/\/(www\.)?deezer.com\/([a-zA-Z]+\/)?track\/[0-9]+/,
  playlistNalbums: /(^https:)\/\/(www\.)?deezer.com\/[a-zA-Z]+\/(playlist|album)\/[0-9]+(\?)?(.*)/,
  share: /(^https:)\/\/dzr\.page\.link\/[A-Za-z0-9]+/
};
function validate(query) {
  return deezerRegex.track.test(query) ?? deezerRegex.playlistNalbums.test(query) ?? deezerRegex.share.test(query);
}

// src/DeezerExtractor.ts
var Warnings = {
  MissingDecryption: "Decryption Key missing! This is needed for extracting streams."
};
function parseCookie(obj) {
  let str = "";
  for (const key of Object.keys(obj)) {
    str += ` ${key}=${obj[key]};`;
  }
  return str.trim();
}
async function fetchDeezerUser(ext) {
  const crypto = await getCrypto();
  const randomToken = crypto.randomBytes(16).toString("hex");
  const deezerUsrDataUrl = `https://www.deezer.com/ajax/gw-light.php?method=deezer.getUserData&input=3&api_version=1.0&api_token=${randomToken}`;
  const usrDataRes = await ext.fetch(deezerUsrDataUrl);
  const usrData = await usrDataRes.json();
  const licenseToken = usrData.results.USER.OPTIONS.license_token;
  if (typeof licenseToken !== "string")
    throw new Error("Unable to get licenseToken");
  const csrfToken = usrData.results.checkForm;
  if (typeof csrfToken !== "string")
    throw new Error(
      "Unable to get csrf token which is required for decryption"
    );
  return {
    cookie: usrDataRes.headers.get("set-cookie"),
    licenseToken,
    csrfToken,
    mediaUrl: usrData.results.URL_MEDIA || "https://media.deezer.com"
  };
}
var DeezerExtractor = class extends import_discord_player2.BaseExtractor {
  async fetch(input, options) {
    if (!options) options = {};
    options.headers = {
      Cookie: parseCookie({ arl: this.options.arl }),
      "User-Agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:120.0) Gecko/20100101 Firefox/120.0",
      DNT: "1",
      Origin: "https://www.deezer.com",
      Connection: "keep-alive",
      Referer: "https://www.deezer.com/login",
      ...options?.headers
    };
    return fetch(input, options);
  }
  async activate() {
    this.protocols = ["deezer"];
    if (!this.options.decryptionKey)
      process.emitWarning(Warnings.MissingDecryption);
    else {
      this.userInfo = await fetchDeezerUser(this);
      this.context.player.debug(
        "USER INFO EXT: " + JSON.stringify(this.userInfo)
      );
    }
    if (this.options.priority) {
      this.priority = this.options.priority;
    }
    this.__interval = setInterval(
      async () => {
        try {
          this.userInfo = await fetchDeezerUser(this);
        } catch {
          this.context.player.debug(
            "[DEEZER_EXTRACTOR_ERR]: Unable to fetch user information from Deezer. Retrying in 3 seconds ..."
          );
          await (0, import_promises.setTimeout)(
            3e3
            /* 3 seconds */
          );
          try {
            this.userInfo = await fetchDeezerUser(this);
          } catch (err) {
            this.context.player.debug(
              "[DEEZER_EXTRACTOR_ERR]: Retry failed. Using old user ..."
            );
          }
        }
      },
      this.options.reloadUserInterval || 864e5
      /* one day */
    ).unref();
  }
  async deactivate() {
    if (this.__interval) clearInterval(this.__interval);
    this.protocols = [];
  }
  async validate(query, type) {
    return validate(query) || type === "deezer" || !isUrl(query);
  }
  buildPlaylistData(data, handleContext) {
    const raw = data.url.split("/");
    const identifier = raw[raw.length - 1].split("?")[0];
    return new import_discord_player2.Playlist(this.context.player, {
      title: data.name,
      thumbnail: data.thumbnail[0].url,
      author: {
        name: data.artist.name,
        url: data.artist.url
      },
      type: data.type,
      tracks: data.tracks.map((v) => this.buildTrack(v, handleContext)),
      description: "",
      source: "arbitrary",
      id: identifier,
      url: data.url
    });
  }
  async handle(query, context) {
    if (!isUrl(query)) {
      const rawSearch = await search(query);
      const tracks = buildTrackFromSearch(
        rawSearch,
        this.context.player,
        context.requestedBy
      );
      return this.createResponse(null, tracks);
    }
    if (deezerRegex.share.test(query)) {
      const redirect = await this.fetch(query);
      query = redirect.url;
    }
    const metadata = await (0, import_deezer_music_metadata.getData)(query);
    if (metadata?.type === "song")
      return this.createResponse(null, [this.buildTrack(metadata, context)]);
    if (metadata?.type === "playlist" || metadata?.type === "album") {
      const playlist = this.buildPlaylistData(metadata, context);
      return this.createResponse(playlist, playlist.tracks);
    }
    throw new Error("Unable to get data from Deezer");
  }
  buildTrack(track, { requestedBy }) {
    return new import_discord_player2.Track(this.context.player, {
      title: track.name,
      author: track.author.map((v) => v.name).join(", "),
      url: track.url,
      source: "arbitrary",
      thumbnail: track.thumbnail[0].url,
      duration: import_discord_player2.Util.buildTimeCode(import_discord_player2.Util.parseMS(track.duration)),
      requestedBy
    });
  }
  async bridge(track) {
    const deezerTrack = await searchOneTrack(
      `${track.author} ${track.source === "youtube" ? track.cleanTitle : track.title}`
    );
    if (!deezerTrack) return null;
    const dpTrack = buildTrackFromSearch(
      deezerTrack,
      this.context.player,
      track.requestedBy
    );
    const stream = this.stream(dpTrack[0]);
    return stream;
  }
  stream(info) {
    return streamTrack(info, this);
  }
};
DeezerExtractor.identifier = "com.retrouser955.discord-player.deezr-ext";

// src/Crypto/NodeDecryptor.ts
var NodeDecryptor = class extends BaseDecryptor {
  constructor(...args) {
    super(...args);
    (async () => {
      if (!(await getCrypto()).getCiphers().includes("bf-cbc")) throw new Error("Cannot find bf-cbc");
    })();
  }
  async decrypt(chunk) {
    const crypto = await getCrypto();
    const decipher = crypto.createDecipheriv("bf-cbc", this.key, this.iv).setAutoPadding(false);
    return Buffer.concat([decipher.update(chunk), decipher.final()]);
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  BaseDecryptor,
  DeezerExtractor,
  JSDecryptor,
  NodeDecryptor,
  Warnings,
  buildTrackFromSearch,
  deezerRegex,
  extractTrackId,
  getCrypto,
  isUrl,
  search,
  searchOneTrack,
  streamTrack,
  validate
});
