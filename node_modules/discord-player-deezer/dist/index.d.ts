import { Playlist, Track as Track$1 } from '@mithron/deezer-music-metadata';
import { Track, ExtractorStreamable, BaseExtractor, SearchQueryType, ExtractorSearchContext, Playlist as Playlist$1, ExtractorInfo, Player } from 'discord-player';
import * as crypto from 'crypto';
import { PassThrough } from 'stream';
import Blowfish from 'blowfish-node';

declare class BaseDecryptor {
    key: Buffer;
    iv: Buffer;
    constructor(decryptionKey: Buffer, iv: Buffer);
    decrypt(chunk: Buffer): Promise<Buffer>;
}

/**
 * -------------------------------NOTICE-------------------------------------
 * STREAMING CODE IS MAINLY TAKEN FROM https://github.com/PerformanC/NodeLink
 * WHICH HAS THE "BSD 2-Clause "Simplified" License"
 *
 * PLEASE SHOW THE ORIGINAL AUTHOR SUPPORT BY STARING HIS GITHUB REPO
 * --------------------------------------------------------------------------
 */
type DeezerExtractorOptions = {
    decryptionKey?: string;
    createStream?: (track: Track, ext: DeezerExtractor) => Promise<ExtractorStreamable>;
    searchLimit?: number;
    reloadUserInterval?: number;
    priority?: number;
    arl: string;
    decryptor?: typeof BaseDecryptor;
};
type DeezerUserInfo = {
    cookie: string;
    licenseToken: string;
    csrfToken: string;
    mediaUrl: string;
};
declare const Warnings: {
    readonly MissingDecryption: "Decryption Key missing! This is needed for extracting streams.";
};
type Warnings = (typeof Warnings)[keyof typeof Warnings];
declare class DeezerExtractor extends BaseExtractor<DeezerExtractorOptions> {
    static readonly identifier: string;
    userInfo: DeezerUserInfo;
    __interval?: ReturnType<typeof setInterval>;
    fetch(input: Parameters<typeof fetch>[0], options?: Parameters<typeof fetch>[1]): Promise<Response>;
    activate(): Promise<void>;
    deactivate(): Promise<void>;
    validate(query: string, type: SearchQueryType & "deezer"): Promise<boolean>;
    buildPlaylistData(data: Playlist, handleContext: ExtractorSearchContext): Playlist$1;
    handle(query: string, context: ExtractorSearchContext): Promise<ExtractorInfo>;
    buildTrack(track: Track$1, { requestedBy }: ExtractorSearchContext): Track<unknown>;
    bridge(track: Track): Promise<ExtractorStreamable | null>;
    stream(info: Track): Promise<ExtractorStreamable>;
}

declare function getCrypto(): Promise<typeof crypto>;
declare function isUrl(query: string): boolean;
declare function search(query: string, limit?: number): Promise<DeezerSearchTrackResponse>;
type ArrayOrObject<T> = T | T[];
interface DeezerSearchTrackResponse {
    data: {
        link: string;
        title: string;
        album: {
            cover_xl?: string;
            cover_medium?: string;
            cover_small?: string;
            cover?: string;
        };
        artist: {
            name: string;
        };
        duration: number;
        type: "track";
    }[];
}
declare function buildTrackFromSearch(track: DeezerSearchTrackResponse, player: Player, requestedBy?: Track["requestedBy"]): Track<unknown>[];
declare function extractTrackId(query: string): string;
declare function searchOneTrack(query: string): Promise<DeezerSearchTrackResponse | undefined>;
declare function streamTrack(track: Track, ext: DeezerExtractor): Promise<PassThrough>;
declare const deezerRegex: {
    readonly track: RegExp;
    readonly playlistNalbums: RegExp;
    readonly share: RegExp;
};
declare function validate(query: string): boolean;

declare class JSDecryptor extends BaseDecryptor {
    bfDecryptor: Blowfish;
    constructor(...args: ConstructorParameters<typeof BaseDecryptor>);
    decrypt(chunk: Buffer): Promise<Buffer>;
}

declare class NodeDecryptor extends BaseDecryptor {
    constructor(...args: ConstructorParameters<typeof BaseDecryptor>);
    decrypt(chunk: Buffer): Promise<Buffer>;
}

export { type ArrayOrObject, BaseDecryptor, DeezerExtractor, type DeezerExtractorOptions, type DeezerSearchTrackResponse, type DeezerUserInfo, JSDecryptor, NodeDecryptor, Warnings, buildTrackFromSearch, deezerRegex, extractTrackId, getCrypto, isUrl, search, searchOneTrack, streamTrack, validate };
